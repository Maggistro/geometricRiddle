\chapter{Discussion}
Through applying a local approach to builing the configuration space, the riddles are starting to become solvable in an acceptable timeframe.
Still, the time it takes to solve a riddle can vary strong depending on the number of objects, their start configuration and their shape. Furthermore there are still some unsolved problems in general and depending on the used implementation

\section{General Problems}
\subsection{Infinite rotation}
%insert graphic spiral riddle
GRAPHIC WITH A HUGE SPIRAL REQUIERING THE OBJECT TO ROTATE OVER 360° TO SOLVE\\
As earch object can be rotated a total 360° to get back to its starting position, the first thing that comes into mind is that rotations are infinite. The problem with this viewpoint is, that the configuration space would also be infinite in each rotation direction per object. This makes it impossible to calculate the configuration space beforehand, because to do so, each possible combination of objects needs to be checked. But with multiple infinite axis, this would be an infinite number and calculations would never come to an end. \\
The solution to this problem lies in the local search method applied in the algorithm. It views the rotation axis as a stack of configuration hyperplanes per object. If you rotate an arbitrary object o, you simply move up/down in the stack of hyperplanes for said object. \\
The downside to that is, that in order to build a stack, there is the need to define a stepsize in which to move up and down the stack and change the rotation. This leads to another scale factor which needs to be set so that adequate accuracy can be achieved. One has to choose either less accuracy for less calculations or more calculations for higher accuracy.


\section{Problems with point list implementation}
\subsection{Invisible plains}
An invisible plain is a plain extending from the vector of one object beetween two of its points. This plain splits the search space in two parts. Due to the fact, that we use this effect to split the space in cells, which we use for nodes in our search graph, changes to these plains affect our graph.\\
%iinsert graphic about two objects with plains interfearing
GRAPHIC WITH TWO OBJECTS PLAINS INTERFEARING\\
If we take a look at this example, we can see how the object o1 dictates the cell border for object o2 on the left. If we move o2 over the border, it now takes over the cell border for object o1. Without a given heuristic which object is better to be moved to the right, this will end in alternating movements for both objects.\\
But if we choose o1 to be the main object, which has a target on the right, the heuristic would need to tell our search algorithm that the point with o1 beeing right of o2 is the better point, and search from there on further, meaning o1 beeing moved to the right cell border again.
GRAPHIC WITH O1 AS MAIN OBJECT???

\section{Problems with function list implementation}
\subsection{Vertical lines}
Due to the nature of a function, vertical lines can not be represented. This leads to the rule that all objects in the riddle can not have a vertical line even after rotating. 
To still be able to draw an object with a vertical line, a function is defined with a very high gradient and setting the starting point at the x-coordinate of the vertical line. This leads to a near vertical line, that is still a function, and as such can be used in the calculations.\\
The drawback is clearly the loss of preciseness. How strong this loss is depends on the initial gradiant one gives the function. A seemingly good idea would be to use the max value of the variables used in calculations (e.g. double = $1.7977 \cdot 10^308$ ). But if we do this without beeing sure that this value will never be used in a way, such that the solution of a calculation could be greater than the gradiant, we would get a overflow.\\
Thus, a value needs to be found that leaves enough room for calculations and still keeps the precisionloss as small as possible. The exakt number depends on the system the algorithm is used in. Also one needs to cap the gradient after each rotation, so that it does not exceed the given max value.


