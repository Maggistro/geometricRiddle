\chapter{Implementation}
\label{cha:Implementation}

\section{Algorithms and Functions}

\subsection{Main search loop}
As proposed in \ref{subsec:confspace}, we create the graph while searching. This requires a certain level of interleaving beetween the search algorithm and the way we work with our objects. In this example, the functions working on the objects are $oneStep(...)$ and $isValid(...)$. All of the rest is needed for the search algorithm, in this case a simple djikstra.
\lstset{language=Matlab}
\begin{lstlisting}
%while target is not in rim
while(~ismember(target,R))
    %select current node from rim
    next = getNodeFromRim();  
    %calculate rimnodes of current node 
    for i=1:length(directions) % find next node for each search direction
        [possible_next,next_collision_set] = oneStep(next,....); 
        if isValid(possible_next,riddle.b,next_collision_set) % check if node is valid and...
            if ~isInRim(possible_next,R) % ...not in the rim
                R=[R;possible_next]; %if so, add it
                collision_set{length(D)+1} = next_collision_set; %set his collision information
                D=[D;D(next_position)+0.1]; %enter distance to predecessor
                P=[P;next]; %enter next as predecessor
                H=[H;heuristic(possible_next,target)]; %calculate heuristic value
                V=[V;0]; %mark as not visited
            else                    %... already in the rim
                pn_position=find(possible_next,R); %search the node in the rim
                if(D(pn_position)>D(next_position)+0.1) % if node in rim is further away as new node...
                    D(pn_position)=D(next_position)+0.1; %... update distance
                    P(pn_position,:)=next; % and chance predecessor
                end %else do nothing
            end
    end  
end
\end{lstlisting}

\subsection{The function oneStep}
$[\textbf{nextNode}, \textbf{newCollSet} ]=oneStep(\textbf{node, direction, collSet,riddle, jump\_over})$ is the function that provides us with the next node in a specific direction and an updated collision set for that node. This new collision set equals a new hyperplane in the configuration space at the position of the next node.\\
Parameters:
\begin{itemize}
\item \textbf{node}: a point in the configurationspace $C$ used as the starting point.
\item \textbf{direction}: the dimension of $C$ to search a new node on. Signed means search backward, unsigned forward. 
\item \textbf{collSet}: $i$ sets of $n-1$ sized sets giving the collisionsets $C_{O_i-O_j}$ per object $O_i$ for all $n$ objects.
\item \textbf{riddle}: the original set of information for the starting riddle. Needed for recalculation of collSets.
\item \textbf{jump\_over}: flag for signaling if next node should be on the rim of current cell ( jump\_over = -1), or in the next cell ( jump\_over = 1).
\end{itemize}
Returns:
\begin{itemize}
\item \textbf{nextNode}: the next point in the configuration space from \textbf{node} along the dimension \textbf{direction}.
\item \textbf{newCollSet}: the new collisionset for the objects at the configuration \textbf{nextNode}.
\end{itemize}
The fucntion can be divided in two different step types: rotation and translation. \\
All rotations are executed by changing the dimension \textbf{direction}  depending on the sign of \textbf{direction} by one step. The size of the step is determined by the needed accuracy. \\
On the other side stands the translation step. As our goal is to identify the next cell in the dimension \textbf{direction}, we iterate over all convex hulls stored in \textbf{collSet} for the object that needs changing and extend their borders. A jump over/to the nearest border in a given direction equals a jump into the next / to the border of the cell.\\
First we take two points from the convex hull (named points) and recalculate the vector. Due to the fact that each object only resideds in a 2 dimensional space, by solving a linear equation we get the crossing points on on the dimension that is NOT our search dimension $direction$, so that we can calculate the point in this direction.
\begin{lstlisting}
...
        %calculate line from points
        offset = points(i,:);
        vector = points(mod(i,length(points))+1,:)-points(i,:);

        %solve for x and y points
        x =  vector\(node((object_pos-1)*3+1:(object_pos-1)*3+2) - offset) ;
...    
    
...        
        %get point on same x,y coordinate
        %check if line is parallel to searching direction
        if(vector(mod(mod(abs(direction),3),2)+1)<0.001)
            continue;
        end

        %get x to move in y direction and otherwise
        if(mod(abs(direction),3)==1)
            if(x(2,2)<0.001)
                continue;
            end
            p = offset + x(2,2)*vector;%get point on same y
        else
            if(x(1,1)<0.001)
                continue;
            end
            p = offset + x(1,1)*vector;%get point on same x
        end
 \end{lstlisting}
Before we calculate this point, we check if we already reached our target cell by trying to get a non-intercepted connection from the current \textbf{node} to the target node taken from \textbf{riddle}. The flag needs to be tchecked for ALL vectors.       
\begin{lstlisting}
    %check if point is in same cell as target
        if(inTargetCell)
            %find out if direct way to target is possible
            temp=(node(1:2) - offset)';
            A=[vector', -node_to_target];
            sol = A\temp;
            
            point_on_line = offset + sol(1)*vector;
            point_on_line = node(1:2)' + sol(2)*node_to_target;
            
            %check if lines intersect (aka way to target is free )
            if(sol(1)>=0 && sol(1)<=1 && sol(2)>=0 && sol(2)<=1)
                inTargetCell = inTargetCell && false;
            end    
        end
\end{lstlisting}
If all checks out, we calculate the vector from \textbf{node} to the crossing point on the border. If the sign of the vector along the dimension \textbf{direction} equals that of \textbf{direction} a distance is calculated and, if lower than the current minimum, stored together with a possible new node \textbf{nextNode}.
This next node is choosen depending on the flag \textbf{jump\_over} to either be directly infront or behind the point on the border.
\begin{lstlisting}
        %vector from node to temp point on line
        node_to_point = p-node((object_pos-1)*3+1:(object_pos-1)*3+2);
        %get distance to those points if direction is ok
        if sign(node_to_point(mod(abs(direction),3)))~= sign(direction)
            d = inf;
        else
            d = norm(p - node((object_pos-1)*3+1:(object_pos-1)*3+2));
        end
        
        %save new minimum and new point on line
        if d < min_dist
            min_dist = min(min_dist,d);
            if (jump_over==1)
            nextNode((object_pos-1)*3+1:(object_pos-1)*3+2) = p + (node_to_point~=0)*0.001;
            else
            nextNode((object_pos-1)*3+1:(object_pos-1)*3+2) = p - (node_to_point~=0)*0.001;
            end
        end
        
...
\end{lstlisting}
Now after this loop has finished, we have found either a new minimum in the searching direction or we are inside the same cell as the target. \\
If we are in the same cell as the target, we just set the main object $M$ to the targets configuration and return.
\begin{lstlisting}
if inTargetCell && object_pos==1
    nextNode(1:3) = riddle.t.mid;
    return
end
\end{lstlisting}
If we found a new minimum, the collisionsets need to be adapted. For that we recalculate the new configuration state \textbf{nextNode} of our objects with the help of $changeOneObject(...)$.
\begin{lstlisting}
   for object=1:length(riddle.o)
        riddle.o{object} = changeOneObject(nextNode((object-1)*3+1:object*3),riddle.o{object});    
    end
\end{lstlisting}
Afterwards we iterate over the newly generated objects and recalculate the collision sets per object with $getRims(...)$.
\begin{lstlisting}
for object=1:length(riddle.o)
        temp = riddle.o;
        temp(object) = [];
        newCollSet{object}= getRims(riddle.o{object}.data,temp,...
            length(riddle.o{object}.data),riddle.o{object}.mid);
end
\end{lstlisting}
This \textbf{newCollSet} is then returned together with \textbf{nextNode}.

\subsection{isValid}
%TODO
\subsection{Helper functions}
Providing a better insight into the code, some of the most important helper functions are explained in detail. For all other functions, the code manual will be used as a reference.
\subsubsection{getRims}
%TODO
\subsubsection{changeOneObject}
%TODO
